<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Multi-finger Kryptonite Comet Simulator</title>
<style>
  :root { --ui-bg: rgba(0,0,0,.5); --ui-on: #36f; --ui-off: #444; --accent: #5ff06a; }
  html,body { height:100%; margin:0; background:black; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; }
  canvas { display:block; width:100vw; height:100vh; }
  #ui {
    position: absolute;
    left: 10px;
    top: 10px;
    z-index: 50;
    padding: 8px;
    border-radius: 10px;
    background: var(--ui-bg);
    color: white;
    font-family: system-ui, -apple-system, Roboto, "Segoe UI", Arial;
    font-size: 14px;
  }
  #ui button {
    background: transparent;
    border: 1px solid rgba(255,255,255,.15);
    color: white;
    padding:6px 10px;
    border-radius:6px;
    margin-left:8px;
  }
  #ui .status { display:inline-block; min-width:60px; text-align:center; padding:4px 8px; border-radius:6px; background: rgba(255,255,255,0.06); margin-right:8px; }
  #info { position:absolute; right:10px; top:10px; color:#ddd; font-size:12px; background: rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; font-family:monospace;}
  @media (prefers-reduced-motion: reduce) { * { transition:none !important; } }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <span class="status" id="gravStatus">Gravity: ON</span>
  <button id="toggleGravity">Toggle Gravity</button>
  <button id="regenPlanets">Regenerate Planets</button>
</div>

<div id="info">Touch to spawn comets — multi-touch supported<br>Planets: variable mass, gravity enabled by default</div>

<script>
(() => {
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;

window.addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

/* -------------------------
   Simulation parameters
   ------------------------- */
const STAR_COUNT = Math.round(Math.min(400, (W*H)/8000));
const COMET_BASE_SIZE = Math.max(10, Math.min(28, Math.min(W,H)/40));
const TRAIL_LENGTH = 28;
const MAX_ACCEL = 0.45;           // how strongly comets accelerate toward touch (tune)
const SMOOTHING = 0.12;           // lower -> smoother turning
const FRICTION = 0.996;           // space damping
const GRAVITY_SCALE = 0.0009;     // global gravity multiplier (tweak to taste)
const PLANET_COUNT = 5;           // how many planets to generate
const RESTITUTION = 0.87;         // bounce elasticity for comet collisions
const MIN_PLANET_DIST = 120;      // avoid spawning planets too close to starting center

/* -------------------------
   Starfield
   ------------------------- */
const stars = [];
for (let i=0;i<STAR_COUNT;i++){
  stars.push({
    x: Math.random()*W,
    y: Math.random()*H,
    r: Math.random()*1.6 + 0.3,
    layer: Math.random()*0.9+0.1
  });
}

/* -------------------------
   Planets (random variable mass)
   ------------------------- */
let planets = [];
function randColor() {
  const h = Math.floor(Math.random()*360);
  const s = 60 + Math.random()*30;
  const l = 40 + Math.random()*15;
  return `hsl(${h} ${s}% ${l}%)`;
}
function generatePlanets(n=PLANET_COUNT){
  planets = [];
  for (let i=0;i<n;i++){
    let size = 18 + Math.random()*60; // visual size
    // ensure not too close to center spawn area
    let x,y;
    let tries = 0;
    do {
      x = 40 + Math.random()*(W-80);
      y = 40 + Math.random()*(H-80);
      tries++;
      if (tries>50) break;
    } while (Math.hypot(x - W/2, y - H/2) < MIN_PLANET_DIST);
    let mass = (size * (60 + Math.random()*240)); // mass proportional but with variance
    planets.push({ x,y,size,mass, color: randColor(), angle: Math.random()*Math.PI*2, spin: (Math.random()-0.5)*0.0007 });
  }
}
generatePlanets();

/* -------------------------
   Comets (one per pointer)
   ------------------------- */
const comets = new Map(); // pointerId -> comet object

function makeComet(x,y, size = COMET_BASE_SIZE){
  return {
    id: null,
    x,y,
    vx: (Math.random()-0.5)*0.6,
    vy: (Math.random()-0.5)*0.6,
    size,
    mass: size*0.9 + Math.random()*2,
    trail: [],
    target: { x,y }, // pointer target
    hasTarget: false,
  };
}

/* -------------------------
   Pointer handling (multi-touch)
   ------------------------- */
function onPointerDown(ev){
  ev.preventDefault();
  const id = ev.pointerId;
  canvas.setPointerCapture && canvas.setPointerCapture(id);
  // spawn comet at the touch point
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  const comet = makeComet(x,y, COMET_BASE_SIZE + (Math.random()*8 - 4));
  comet.id = id;
  comet.target.x = x; comet.target.y = y;
  comet.hasTarget = true;
  comets.set(id, comet);
}
function onPointerMove(ev){
  ev.preventDefault();
  const id = ev.pointerId;
  const comet = comets.get(id);
  if (!comet) return;
  const rect = canvas.getBoundingClientRect();
  comet.target.x = ev.clientX - rect.left;
  comet.target.y = ev.clientY - rect.top;
  comet.hasTarget = true;
}
function onPointerUp(ev){
  ev.preventDefault();
  const id = ev.pointerId;
  const comet = comets.get(id);
  if (!comet) return;
  // release target but keep the comet drifting
  comet.hasTarget = false;
  canvas.releasePointerCapture && canvas.releasePointerCapture(id);
  // remove the comet after a short delay? we'll keep it until user wants otherwise.
  // Optionally: remove on up: comets.delete(id); // but user wanted lifting removes earlier — user requested earlier that lifting removes comet; they also asked "Lifting a finger removes that comet" previously — need to implement removal on up.
  comets.delete(id);
}

/* The user earlier requested: "Lifting a finger removes that comet from the simulation."
   So we'll remove the comet on pointerup (done above). If you prefer it to stay, comment that line out. */

canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
canvas.addEventListener('pointermove', onPointerMove, {passive:false});
canvas.addEventListener('pointerup', onPointerUp, {passive:false});
canvas.addEventListener('pointercancel', onPointerUp, {passive:false});
canvas.addEventListener('pointerout', onPointerUp, {passive:false});
canvas.addEventListener('pointerleave', onPointerUp, {passive:false});

/* -------------------------
   Collision resolution (circle vs circle)
   ------------------------- */
function resolveCollision(a,b){
  // minimal translation to separate
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  let dist = Math.hypot(dx,dy);
  if (dist === 0) {
    // apply small random separation
    dist = 0.001;
  }
  const overlap = a.size + b.size - dist;
  if (overlap > 0) {
    // push them apart proportional to mass
    const nx = dx/dist;
    const ny = dy/dist;
    const totalMass = a.mass + b.mass;
    const ratioA = b.mass / totalMass;
    const ratioB = a.mass / totalMass;
    a.x -= nx * overlap * ratioA;
    a.y -= ny * overlap * ratioA;
    b.x += nx * overlap * ratioB;
    b.y += ny * overlap * ratioB;

    // velocity projection for 1D collision along normal
    const relativeVx = b.vx - a.vx;
    const relativeVy = b.vy - a.vy;
    const relVelAlongNormal = relativeVx * nx + relativeVy * ny;

    if (relVelAlongNormal > 0) return; // moving apart already

    // compute impulse scalar (elastic-ish)
    const e = RESTITUTION;
    const j = -(1 + e) * relVelAlongNormal / (1/a.mass + 1/b.mass);

    const impulseX = j * nx;
    const impulseY = j * ny;

    a.vx -= impulseX / a.mass;
    a.vy -= impulseY / a.mass;
    b.vx += impulseX / b.mass;
    b.vy += impulseY / b.mass;
  }
}

/* -------------------------
   Physics & update
   ------------------------- */
let gravityEnabled = true;
const gravStatus = document.getElementById('gravStatus');
document.getElementById('toggleGravity').addEventListener('click', () => {
  gravityEnabled = !gravityEnabled;
  gravStatus.textContent = `Gravity: ${gravityEnabled ? 'ON' : 'OFF'}`;
});

document.getElementById('regenPlanets').addEventListener('click', () => {
  generatePlanets();
});

function applyPlanetGravity(comet){
  if (!gravityEnabled) return;
  // sum forces from planets
  for (let p of planets){
    const dx = p.x - comet.x;
    const dy = p.y - comet.y;
    const distSq = dx*dx + dy*dy;
    const minDist = Math.max((p.size + comet.size) * 0.5, 10);
    // avoid singularity
    const safeDistSq = Math.max(distSq, minDist*minDist);
    const dist = Math.sqrt(safeDistSq);
    // inverse-square with planet mass and global scale
    const force = (p.mass * GRAVITY_SCALE) / safeDistSq;
    // apply small additional falloff for far away to reduce global dominance
    const fx = (dx / dist) * force;
    const fy = (dy / dist) * force;
    comet.vx += fx;
    comet.vy += fy;
  }
}

function update(dt){
  // dt in seconds approx (but we use frame-independent scaling lightly)
  const cometArray = Array.from(comets.values());

  // apply controls & gravity
  for (let c of cometArray){
    // smooth target steering: compute desired acceleration toward target if any
    if (c.hasTarget) {
      const dx = c.target.x - c.x;
      const dy = c.target.y - c.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 0.6) {
        // normalized direction
        const nx = dx / dist;
        const ny = dy / dist;
        // compute acceleration magnitude proportional to distance but clipped
        // smooth steering so comet accelerates and slows near target
        const desiredAcc = Math.min(MAX_ACCEL, dist * 0.02);
        // blend new acceleration into velocity with smoothing
        c.vx += nx * desiredAcc * SMOOTHING;
        c.vy += ny * desiredAcc * SMOOTHING;
        // if we are pretty close, apply a braking factor
        if (dist < c.size * 1.3) {
          c.vx *= 0.9;
          c.vy *= 0.9;
        }
      }
    }

    // planet gravity
    applyPlanetGravity(c);

    // friction/damping
    c.vx *= FRICTION;
    c.vy *= FRICTION;

    // update position
    c.x += c.vx;
    c.y += c.vy;

    // wrap-around edges
    if (c.x < -50) c.x = W + 50;
    if (c.x > W + 50) c.x = -50;
    if (c.y < -50) c.y = H + 50;
    if (c.y > H + 50) c.y = -50;

    // push into trail
    c.trail.push({ x: c.x, y: c.y });
    if (c.trail.length > TRAIL_LENGTH) c.trail.shift();
  }

  // collisions between comets (pairwise)
  for (let i=0;i<cometArray.length;i++){
    for (let j=i+1;j<cometArray.length;j++){
      resolveCollision(cometArray[i], cometArray[j]);
    }
  }
}

/* -------------------------
   Rendering helpers
   ------------------------- */
function drawStarfield(){
  // a simple gradient background
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, '#000014');
  g.addColorStop(1, '#000000');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // draw stars with parallax based on average comet velocity
  let avgVx = 0, avgVy = 0, count = 0;
  for (let c of comets.values()){
    avgVx += c.vx; avgVy += c.vy; count++;
  }
  if (count>0) { avgVx /= count; avgVy /= count; }
  // move stars slightly opposite to motion for depth
  for (let s of stars){
    s.x += -avgVx * 0.02 * s.layer;
    s.y += -avgVy * 0.02 * s.layer;
    if (s.x < 0) s.x = W;
    if (s.x > W) s.x = 0;
    if (s.y < 0) s.y = H;
    if (s.y > H) s.y = 0;
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r * (0.6 + s.layer*0.8), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawPlanets(){
  for (let p of planets){
    // subtle pulsating glow
    const g = ctx.createRadialGradient(p.x, p.y, p.size*0.2, p.x, p.y, p.size*1.8);
    g.addColorStop(0, 'rgba(255,255,255,0.9)');
    g.addColorStop(0.12, p.color);
    g.addColorStop(0.9, 'rgba(0,0,0,0.0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size*1.2, 0, Math.PI*2);
    ctx.fill();

    // planet body
    const body = ctx.createRadialGradient(p.x - p.size*0.4, p.y - p.size*0.4, p.size*0.1, p.x, p.y, p.size);
    body.addColorStop(0, '#fffef7');
    body.addColorStop(0.35, p.color);
    body.addColorStop(1, 'rgba(0,0,0,0.4)');
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();

    // thin rim
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
    ctx.stroke();
  }
}

function drawCometRock(c){
  // draw trail (glowing)
  if (c.trail.length > 1){
    ctx.beginPath();
    for (let i=0;i<c.trail.length;i++){
      const p = c.trail[i];
      if (i==0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.strokeStyle = 'rgba(90,255,120,0.18)';
    ctx.lineWidth = Math.max(1, c.size*0.6);
    ctx.stroke();
  }

  // rock-ish body using gradients & speckles
  const gx = ctx.createRadialGradient(c.x - c.size*0.2, c.y - c.size*0.2, c.size*0.08, c.x, c.y, c.size);
  gx.addColorStop(0, '#bfffbe'); // bright center
  gx.addColorStop(0.45, '#40f660'); // lime
  gx.addColorStop(1, '#083e12'); // dark green edge
  ctx.fillStyle = gx;

  ctx.save();
  // outer glow
  ctx.shadowColor = '#66ff88';
  ctx.shadowBlur = 18;
  ctx.beginPath();
  // irregular rock silhouette: draw circle but slightly jitter points for roughness
  const steps = 22;
  ctx.moveTo(c.x + c.size, c.y);
  for (let i=0;i<=steps;i++){
    const t = (i/steps) * Math.PI*2;
    const jitter = 1 + (Math.sin(i*3 + (c.x+c.y)*0.001) * 0.12) + (Math.random()*0.06);
    const rx = c.x + Math.cos(t) * c.size * jitter * (0.85 + Math.sin(i*7 + c.x*0.001)*0.15);
    const ry = c.y + Math.sin(t) * c.size * jitter * (0.85 + Math.cos(i*5 + c.y*0.001)*0.12);
    ctx.lineTo(rx, ry);
  }
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // small dark craters/speckles
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  for (let i=0;i<6;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.random()*c.size*0.6;
    const sx = c.x + Math.cos(a)*r;
    const sy = c.y + Math.sin(a)*r;
    ctx.beginPath();
    ctx.arc(sx, sy, Math.random()*c.size*0.18 + 1.2, 0, Math.PI*2);
    ctx.fill();
  }

  // bright specular
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.arc(c.x - c.size*0.28, c.y - c.size*0.28, Math.max(1, c.size*0.18), 0, Math.PI*2);
  ctx.fill();
}

/* -------------------------
   Main loop
   ------------------------- */
let last = performance.now();
function frame(t){
  const dt = Math.min(0.035, (t - last) / 1000); // clamp
  last = t;

  update(dt);

  // render
  drawStarfield();
  drawPlanets();

  // draw comets (sorted for simple layering by y)
  const drawList = Array.from(comets.values()).sort((a,b)=>a.y-b.y);
  for (let c of drawList) drawCometRock(c);

  // HUD (small)
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(8, 56, 160, 2);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* -------------------------
   Nice: allow mouse to create comets when testing on desktop
   ------------------------- */
let mouseDown = false;
window.addEventListener('mousedown', (e)=> {
  mouseDown = true;
  // emulate pointer with id 9999
  const fake = { pointerId: 9999, clientX: e.clientX, clientY: e.clientY };
  onPointerDown(fake);
});
window.addEventListener('mousemove', (e)=> {
  if (!mouseDown) return;
  const fake = { pointerId: 9999, clientX: e.clientX, clientY: e.clientY };
  onPointerMove(fake);
});
window.addEventListener('mouseup', (e)=> {
  if (!mouseDown) return;
  mouseDown = false;
  const fake = { pointerId: 9999, clientX: e.clientX, clientY: e.clientY };
  onPointerUp(fake);
});

/* -------------------------
   Helpful tip: remove leftover comets on long idle
   ------------------------- */
// not required; left commented. If you prefer comets to remain after lift, remove the delete from onPointerUp above.

})(); // IIFE end
</script>
</body>
</html>
